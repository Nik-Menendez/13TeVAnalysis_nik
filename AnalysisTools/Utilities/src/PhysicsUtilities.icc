#ifndef PHYSICSUTILITIES_ICC
#define PHYSICSUTILITIES_ICC

#include<TString.h>
#include "AnalysisTools/Utilities/interface/PhysicsUtilities.h"

using namespace ucsbsusy;

/********************/
/*   Computations   */
/********************/

//_____________________________________________________________________________
// Count Objects
//_____________________________________________________________________________
template<typename Object, typename ObjectPtr>
size PhysicsUtilities::countObjectsDeref(const std::vector<ObjectPtr>& objects, double minPT, double maxEta, bool (*test)(const Object&))
{
  const size          numObjects    = objects.size();
  size                count         = 0;
  for (size iObject = 0; iObject < numObjects; ++iObject) {
    if (test && !(*test)(*objects[iObject]))            continue;
    if (objects[iObject]->pt()              < minPT)    continue;
    if (TMath::Abs(objects[iObject]->eta()) > maxEta)   continue;
    ++count;
  } // end loop over objects
  return count;
}

//_____________________________________________________________________________
template<typename ObjectPtr>
size PhysicsUtilities::countObjectsDeref(const std::vector<ObjectPtr>& objects, double minPT, double maxEta)
{
  const size          numObjects    = objects.size();
  size                count         = 0;
  for (size iObject = 0; iObject < numObjects; ++iObject) {
    if (objects[iObject]->pt()              < minPT)    continue;
    if (TMath::Abs(objects[iObject]->eta()) > maxEta)   continue;
    ++count;
  } // end loop over objects
  return count;
}

//_____________________________________________________________________________
template<typename Object>
size PhysicsUtilities::countObjects(const std::vector<Object>& objects, double minPT, double maxEta, bool (*test)(const Object&))
{
  const size          numObjects    = objects.size();
  size                count         = 0;
  for (size iObject = 0; iObject < numObjects; ++iObject) {
    const Object&     object        = objects[iObject];
    if (object.pt()    < minPT ) continue;
    if (absEta(object) > maxEta) continue;
    if (test && !(*test)(object))     continue;
    ++count;
  } // end loop over objects
  return count;
}
//_____________________________________________________________________________
template<typename Object, typename Analyzer>
size PhysicsUtilities::countObjects(const std::vector<Object>& objects, const Analyzer* analyzer, bool (Analyzer::*test)(const Object&) const)
{
  const size            numObjects    = objects.size();
  size                  count         = 0;
  for (size iObject = 0; iObject < numObjects; ++iObject) {
    const Object&       object        = objects[iObject];
    if (analyzer && test && !(analyzer->*test)(object))   continue;
    ++count;
  } // end loop over objects

  return count;
}
//_____________________________________________________________________________
template<typename Object, typename Analyzer>
size PhysicsUtilities::countObjects(const std::vector<Object>& objects, const Analyzer* analyzer, bool (Analyzer::*test)(const Object&) const, double minPT, double maxEta)
{
  const size            numObjects    = objects.size();
  size                  count         = 0;
  for (size iObject = 0; iObject < numObjects; ++iObject) {
    const Object&       object        = objects[iObject];
    if (get(object).pt()    < minPT )                     continue;
    if (absEta(get(object)) > maxEta)                     continue;
    if (analyzer && test && !(analyzer->*test)(object))   continue;
    ++count;
  } // end loop over objects

  return count;
}
//_____________________________________________________________________________
template<typename Property, typename Object>
size PhysicsUtilities::countObjectProperties(const std::vector<Object>& objects, const Property& (Object::*getProperty)() const, double minPT, double maxEta, bool (*test)(const Property&))
{
  const size          numObjects    = objects.size();
  size                count         = 0;
  for (size iObject = 0; iObject < numObjects; ++iObject) {
    const Property&   object        = (objects[iObject].*getProperty)();
    if (get(object).pt()    < minPT ) continue;
    if (absEta(get(object)) > maxEta) continue;
    if (test && !(*test)(object))     continue;
    ++count;
  } // end loop over objects
  return count;
}
//_____________________________________________________________________________
template<typename Object, typename Other>
size PhysicsUtilities::countDistinctObjects(const std::vector<Object>& objects, const std::vector<Other>& vetoNearby, double minDRnearby, double minPT, double maxEta)
{
  const size            numObjects    = objects.size();
  size                  count         = 0;
  for (size iObject = 0; iObject < numObjects; ++iObject) {
    const Object&       object        = objects[iObject];
    if (get(object).pt()    < minPT ) continue;
    if (absEta(get(object)) > maxEta) continue;

    double              nearestDR     = 1e308;
    for (size iVeto = 0; iVeto < vetoNearby.size(); ++iVeto)
      nearestDR         = TMath::Min(nearestDR, deltaR(get(object), get(vetoNearby[iVeto])));
    if (nearestDR > minDRnearby)
      ++count;
  } // end loop over objects

  return count;
}

//_____________________________________________________________________________
template<typename Target, typename Source>
Target PhysicsUtilities::convertTo(Source source, const char name[], bool lenient, bool* good)
{
  Target            converted = static_cast<Target>(source);

  if (static_cast<Source>(converted) != source) {
    const Target    lowest    = !std::numeric_limits<Target>::is_signed
                              ? 0
                              : std::numeric_limits<Target>::has_infinity
                              ? -std::numeric_limits<Target>::infinity()
                              :  std::numeric_limits<Target>::min()
                              ;
    TString         problem;
    problem.Form( "Source value %.10g outside of target range [%.10g,%.10g] for '%s'."
                , (double)  source
                , (double)  lowest
                , (double)  std::numeric_limits<Target>::max()
                , name
                );
    if (good)      *good      = false;
    if (lenient) {
      std::cerr << "WARNING: " << problem << std::endl;
      return  ( source > static_cast<Source>(std::numeric_limits<Target>::max())
              ? std::numeric_limits<Target>::max()
              : lowest
              );
    }
    std::cout << "convertTo()" << problem.Data()<<std::endl;
    assert(false);
  }

  return converted;
}

//_____________________________________________________________________________
template<typename Object>
void PhysicsUtilities::trash(std::vector<Object*>& objects)
{
  const size    numObjects  = objects.size();
  for (size iObj = 0; iObj < numObjects; ++iObj)
    if (objects[iObj])      delete objects[iObj];
  objects.clear();
}
//_____________________________________________________________________________
template<typename Key, typename Object>
void PhysicsUtilities::trash(std::map<Key,Object*>& objects)
{
  const typename std::map<Key,Object*>::const_iterator endObjects  = objects.end();
  for (typename std::map<Key,Object*>::iterator iObj = objects.begin(); iObj != endObjects; ++iObj)
    if (iObj->second)       delete iObj->second;
  objects.clear();
}
#endif
