#ifndef BASEUTILITIES_ICC
#define BASEUTILITIES_ICC

#include <iostream>
#include <iomanip>

#include "AnalysisTools/Utilities/interface/BaseUtilities.h"

using namespace ucsbsusy;
using namespace std;


//_____________________________________________________________________________
template<typename Target, typename Source>
Target BaseUtilities::convertTo(Source source, const char name[], bool lenient, bool* good)
{
  Target            converted = static_cast<Target>(source);

  if (static_cast<Source>(converted) != source) {
    const Target    lowest    = !std::numeric_limits<Target>::is_signed
                              ? 0
                              : std::numeric_limits<Target>::has_infinity
                              ? -std::numeric_limits<Target>::infinity()
                              :  std::numeric_limits<Target>::min()
                              ;
    TString         problem;
    problem.Form( "Source value %.10g outside of target range [%.10g,%.10g] for '%s'."
                , (double)  source
                , (double)  lowest
                , (double)  std::numeric_limits<Target>::max()
                , name
                );
    if (good)      *good      = false;
    if (lenient) {
      std::cerr << "WARNING: " << problem << std::endl;
      return  ( source > static_cast<Source>(std::numeric_limits<Target>::max())
              ? std::numeric_limits<Target>::max()
              : lowest
              );
    }
    throw cms::Exception("convertTo()", problem.Data());
  }

  return converted;
}

//_____________________________________________________________________________
template<typename Object>
void BaseUtilities::trash(std::vector<Object*>& objects)
{
  const size    numObjects  = objects.size();
  for (size iObj = 0; iObj < numObjects; ++iObj)
    if (objects[iObj])      delete objects[iObj];
  objects.clear();
}
//_____________________________________________________________________________
template<typename Key, typename Object>
void BaseUtilities::trash(std::map<Key,Object*>& objects)
{
  const typename std::map<Key,Object*>::const_iterator endObjects  = objects.end();
  for (typename std::map<Key,Object*>::iterator iObj = objects.begin(); iObj != endObjects; ++iObj)
    if (iObj->second)       delete iObj->second;
  objects.clear();
}
//_____________________________________________________________________________
template<typename Source, typename Tag, typename Product>
bool BaseUtilities::tryToGet(const Source& source, const Tag& tag, edm::Handle<Product>& product, int numAnalyzed, bool& isAvailable)
{
  if (!isAvailable)   return false;
  if (numAnalyzed == 0) {
    source.getByLabel(tag, product);
    return ( isAvailable = product.isValid() );
  } else {
    source.getByLabel(tag, product);
    return product.isValid();
  }
  return false;
}
//_____________________________________________________________________________
template<typename Source, typename Tag, typename Product>
bool BaseUtilities::tryToGet(const Source& source, const Tag& tag, const Product*& product, int numAnalyzed, bool& isAvailable)
{
  edm::Handle<Product> handle;
  bool returnVal = tryToGet(source,tag,handle,numAnalyzed,isAvailable);
  product = &(*handle);
  return returnVal;
}
//_____________________________________________________________________________
template<typename Source, typename Tag, typename Product>
bool BaseUtilities::enforceGet(const Source& source, const Tag& tag, edm::Handle<Product>& product, bool enforcePresence)
{
  source.getByLabel(tag, product);
  if (enforcePresence) {
    if (product.failedToGet())  throw *product.whyFailed();
    if (!product.isValid())
      throw cms::Exception("BaseUtilities::enforceGet()", ("Product with input tag "+str(tag)+" is not valid.").Data());
  }
  return product.isValid();
}
//_____________________________________________________________________________
template<typename Source, typename Tag, typename Product>
bool BaseUtilities::enforceGet(const Source& source, const Tag& tag, const Product*& product, bool enforcePresence)
{
  edm::Handle<Product> handle;
  bool returnVal = enforceGet(source,tag,handle,enforcePresence);
  product = &(*handle);
  return returnVal;
}
//_____________________________________________________________________________
template<typename Object>
Object* BaseUtilities::getObject(TFile* file, const char* name, const char* alternative, bool stopIfMissing)
{
  if (file == 0)    return 0;

  Object*   object  = ( file->IsZombie() ? 0 : dynamic_cast<Object*>(file->Get(name)) );
  if (object == 0 && alternative)
    object  = ( file->IsZombie() ? 0 : dynamic_cast<Object*>(file->Get(alternative)) );
  if (object == 0) {
    cerr << (stopIfMissing ? "ERROR" : "NOTICE") << " : Failed to read " << name << " from file " << file->GetName() << endl;
    if (stopIfMissing)  throw cms::Exception("EventAnalyzer::getObject()", name);
    else                return 0;
  }
  return object;
}
//_____________________________________________________________________________
template<typename Object>
Object* BaseUtilities::loadObject(TString objectPath, const char* configName, const char* alternative, bool stopIfMissing)
{
  if (objectPath.Length() == 0)     return 0;

  const int           nameIndex     = objectPath.First(':');
  TString             objectName;
  if (nameIndex > 0) {
    objectName        = objectPath(nameIndex + 1, objectPath.Length());
    objectPath.Resize(nameIndex);
  }

  TFile*              objectFile    = open(objectPath, "READ", stopIfMissing);
  if (nameIndex < 0)  throw cms::Exception("EventAnalyzer::loadObject()", "File path and object name must be provided in the syntax 'path:name'.");
  if (configName)     std::clog << " ++  " << left << setw(20) << configName << "= " << objectPath << " [" << objectName << "]" << std::endl;

  Object*             object        = getObject<Object>(objectFile, objectName, alternative, stopIfMissing);
  disassociateFromFile(object);
  objectFile->Close   ();

  return object;
}


#endif
