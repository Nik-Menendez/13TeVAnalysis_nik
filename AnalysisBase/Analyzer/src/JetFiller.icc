#ifndef ANALYSISBASE_ANALYZER_JETFILLER_ICC
#define ANALYSISBASE_ANALYZER_JETFILLER_ICC

#include "AnalysisBase/Analyzer/interface/JetFiller.h"
#include "AnalysisTools/Utilities/interface/JetFlavorMatching.h"
#include "AnalysisTools/Utilities/interface/PartonMatching.h"
#include "AnalysisTools/Utilities/interface/Types.h"

#include "AnalysisBase/Analyzer/interface/EventInfoFiller.h"
#include "AnalysisBase/Analyzer/interface/PFCandidateFiller.h"
#include "AnalysisBase/Analyzer/interface/GenParticleFiller.h"
#include "AnalysisTools/JetShapeVariables/interface/QuarkGluonTagInterface.h"
#include "AnalysisTools/JetShapeVariables/interface/QuarkGluonTaggingVariables.h"

#include "DataFormats/Common/interface/ValueMap.h"

namespace ucsbsusy{

namespace JetFunctions{
  template<typename Jet> bool passLooseJetId(const Jet& j){

    if(fabs(j.eta())>3.0){
      if(j.neutralEmEnergyFraction()<0.90 && j.neutralMultiplicity()>10 ) return true;
      else return false;
    }
    if( !(j.chargedMultiplicity()+j.neutralMultiplicity()>1) ) return false;
    if( !(j.neutralEmEnergyFraction()<0.99)                  ) return false;
    if( !(j.neutralHadronEnergyFraction()<0.99)              ) return false;
    //if( !(j.muonEnergyFraction()<0.8)                        ) return false;
    if(fabs(j.eta())<2.4){
      if( !(j.chargedMultiplicity()>0)         ) return false;
      if( !(j.chargedEmEnergyFraction()<0.99)  ) return false;
      if( !(j.chargedHadronEnergyFraction()>0) ) return false;
    }
    return true;
  }
  template<typename Jet> bool passTightJetId(const Jet& j){
    if(fabs(j.eta())>3.0){
      if(j.neutralEmEnergyFraction()<0.90 && j.neutralMultiplicity()>10 ) return true;
      else return false;
    }
    if( !(j.chargedMultiplicity()+j.neutralMultiplicity()>1) ) return false;
    if( !(j.neutralEmEnergyFraction()<0.9)                   ) return false;
    if( !(j.neutralHadronEnergyFraction()<0.9)               ) return false;
    //if( !(j.muonEnergyFraction()<0.8)                        ) return false;
    if(fabs(j.eta())<2.4){
      if( !(j.chargedMultiplicity()>0)         ) return false;
      if( !(j.chargedEmEnergyFraction()<0.9)   ) return false;
      if( !(j.chargedHadronEnergyFraction()>0) ) return false;
    }
    return true;
  }
  template<typename Jet> bool passMuonEnergyFraction(const Jet& j){
    if(fabs(j.eta())>3.0) return true;
    if( !(j.muonEnergyFraction()<0.8) ) return false;
    return true;
  }
}

//--------------------------------------------------------------------------------------------------
template<typename Jet>
JetFiller<Jet>::JetFiller(const edm::ParameterSet& cfg, edm::ConsumesCollector && cc, const int options, const string branchName, const EventInfoFiller * evtInfoFiller, const GenParticleFiller * genParticleFiller, const PFCandidateFiller * pfCandidateFiller) :
  BaseFiller(options, branchName),
  jetToken_          (cc.consumes<std::vector<Jet> >         (cfg.getParameter<edm::InputTag>("jets"))),
  pfCandToken_       (cc.consumes<pat::PackedCandidateCollection>(cfg.getParameter<edm::InputTag>("pfcands"))),
  reGenJetToken_     (cc.consumes<reco::GenJetCollection>    (cfg.getParameter<edm::InputTag>("reGenJets"))),
  stdGenJetToken_    (cc.consumes<reco::GenJetCollection>    (cfg.getParameter<edm::InputTag>("stdGenJets"))),
  flvAssocToken_     (cc.consumes<std::vector<size8> >       (cfg.getParameter<edm::InputTag>("flvAssoc"))),
  qglToken_          (cc.consumes<edm::ValueMap<float> >     (cfg.getUntrackedParameter<edm::InputTag>("qgLikelihood"))),
  superJetToken_     (cc.consumes<reco::PFJetCollection>     (cfg.getUntrackedParameter<edm::InputTag>("superJets"))),
  superJetAssocToken_(cc.consumes<std::vector<int> >         (cfg.getUntrackedParameter<edm::InputTag>("superJetAssoc"))),
  superJetNsubToken_ (cc.consumes<std::vector<unsigned int> >(cfg.getUntrackedParameter<edm::InputTag>("superJetNsub"))),
  evtInfofiller_     (evtInfoFiller),
  genParticleFiller_ (genParticleFiller),
  pfCandidateFiller_ (pfCandidateFiller),
  qglInterface_      (new QuarkGluonTagInterface),
  qgTaggingVar_      (new QuarkGluonTaggingVariables),
  fillReGenJets_     (cfg.getUntrackedParameter<bool>        ("fillReGenJets")),
  jptCompleteMin_    (cfg.getUntrackedParameter<double>      ("completeMinJetPt")),
  jptMin_            (cfg.getUntrackedParameter<double>      ("minJetPt")),
  jets_              (0),
  reGenJets_         (0),
  stdGenJets_        (0),
  superJets_         (0),
  superJetAssoc_     (0),
  superJetNsub_      (0),
  jecLabel_             (cfg.getUntrackedParameter<std::string>("jecLabel","AK4PFchs")),
  jecUnc_            (0)
{

  if(options_ & LOADUNCFROMFILE) {
    edm::FileInPath           jetCorrInputFileName_ = cfg.getUntrackedParameter<edm::FileInPath>("jetCorrInputFile");
  if ( jetCorrInputFileName_.location() == edm::FileInPath::Unknown) throw cms::Exception("JetFiller");
  JetCorrectorParameters* JetCorPar = new JetCorrectorParameters(jetCorrInputFileName_.fullPath().data(), cfg.getUntrackedParameter<std::string>("jetCorrUncertainty"));
  jecUnc_ = new JetCorrectionUncertainty(*JetCorPar);
  }


  if(!(options_ & LOADGEN) && (options & SAVETOPASSOC)){
    throw cms::Exception( "JetFiller::JetFiller()","You want to save the top tag assoc but not gen jets!");
  }


  ijetpt_          = data.addMulti<float>(branchName_,"jet_pt"          , 0);
  ijeteta_         = data.addMulti<float>(branchName_,"jet_eta"         , 0);
  ijetphi_         = data.addMulti<float>(branchName_,"jet_phi"         , 0);
  ijetmass_        = data.addMulti<float>(branchName_,"jet_mass"        , 0);
  ijetptraw_       = data.addMulti<float>(branchName_,"jet_ptraw"       , 0);
  ijetpuId_        = data.addMulti<float>(branchName_,"jet_puId"        , 0);
  ijetlooseId_     = data.addMulti<bool> (branchName_,"jet_looseId"     , 0);
  ijettightId_     = data.addMulti<bool> (branchName_,"jet_tightId"     , 0);
  if(options_ & FILLJETCHHADN){
    ijetchHadN2_       = data.addMulti<int> (branchName_,"jet_chHadN2"       , 0);
    ijetchHadN4_       = data.addMulti<int> (branchName_,"jet_chHadN4"       , 0);
    ijetchHadN6_       = data.addMulti<int> (branchName_,"jet_chHadN6"       , 0);
  }
  if(options_ & FILLJETEXTRA) {
    ijetchHadEnFrac_   = data.addMulti<float> (branchName_,"jet_chHadEnFrac"   , 0);
    ijetchEmEnFrac_    = data.addMulti<float> (branchName_,"jet_chEmEnFrac"    , 0);
    ijetmuEnFrac_      = data.addMulti<float> (branchName_,"jet_muEnFrac"      , 0);
    ijetelEnFrac_      = data.addMulti<float> (branchName_,"jet_elEnFrac"      , 0);
    ijetneuHadEnFrac_  = data.addMulti<float> (branchName_,"jet_neuHadEnFrac"  , 0);
    ijetneuEmEnFrac_   = data.addMulti<float> (branchName_,"jet_neuEmEnFrac"   , 0);
    ijetphoEnFrac_     = data.addMulti<float> (branchName_,"jet_phoEnFrac"     , 0);
    ijetchMult_        = data.addMulti<int>   (branchName_,"jet_chMult"        , 0);
    ijetneuMult_       = data.addMulti<int>   (branchName_,"jet_neuMult"       , 0);
    ijetchHadMult_     = data.addMulti<int>   (branchName_,"jet_chHadMult"     , 0);
    ijetelMult_        = data.addMulti<int>   (branchName_,"jet_elMult"        , 0);
    ijetmuMult_        = data.addMulti<int>   (branchName_,"jet_muMult"        , 0);
    ijetneuHadMult_    = data.addMulti<int>   (branchName_,"jet_neuHadMult"    , 0);
    ijetphoMult_       = data.addMulti<int>   (branchName_,"jet_phoMult"       , 0);
  }
  ijetcsv_         = data.addMulti<float>(branchName_,"jet_csv"         , 0);
  ijetcvsl_        = data.addMulti<float>(branchName_,"jet_cvsl"        , 0);	
  ijetcvsb_        = data.addMulti<float>(branchName_,"jet_cvsb"        , 0);		
  ijetuncertainty_ = data.addMulti<float>(branchName_, "jet_uncertainty", 0);

  if(options_ & LOADGEN) {
    ijetgenindex_ = data.addMulti<int16  >(branchName_,"jet_genIndex",-1);
    igenjetpt_     = data.addMulti<float>(branchName_,"genjet_pt"    ,0);
    igenjeteta_    = data.addMulti<float>(branchName_,"genjet_eta"   ,0);
    igenjetphi_    = data.addMulti<float>(branchName_,"genjet_phi"   ,0);
    igenjetmass_   = data.addMulti<float>(branchName_,"genjet_mass"  ,0);
    igenjetflavor_ = data.addMulti<size8  >(branchName_,"genjet_flavor",0);

  }
  if(options_ & LOADSUPER) {
    ijetsuperindex_    = data.addMulti<int16  >(branchName_,"jet_superIndex",-1);
    isuperjetpt_       = data.addMulti<float>  (branchName_,"superjet_pt"    ,0);
    isuperjeteta_      = data.addMulti<float>  (branchName_,"superjet_eta"   ,0);
    isuperjetphi_      = data.addMulti<float>  (branchName_,"superjet_phi"   ,0);
    isuperjetmass_     = data.addMulti<float>  (branchName_,"superjet_mass"  ,0);
    isuperjetnsubjets_ = data.addMulti<size16 >(branchName_,"superjet_nsubjets",0);
  }

  if(options_ & LOADJETSHAPE) {
    ijetarea_   = data.addMulti<float>(branchName_,"jet_area"   ,0);
    ijetbetaStar_=data.addMulti<float>(branchName_,"jet_betaStar",0);
    ijetptD_     =data.addMulti<float>(branchName_,"jet_ptD"     ,0);
    ijetaxis1_   =data.addMulti<float>(branchName_,"jet_axis1"   ,0);
    ijetaxis2_   =data.addMulti<float>(branchName_,"jet_axis2"   ,0);
    ijetMult_    =data.addMulti<size16>(branchName_,"jet_jetMult" ,0);
    ijetcharge_  =data.addMulti<float>(branchName_,"jet_charge"    ,0);
    ijetpullrap_ =data.addMulti<float>(branchName_,"jet_pullrap"    ,0);
    ijetpullphi_ =data.addMulti<float>(branchName_,"jet_pullphi"    ,0);
    if(options_ & LOADGEN) {
      igenjetptD_  = data.addMulti<float>(branchName_,"genjet_ptD"    ,0);
      igenjetaxis1_= data.addMulti<float>(branchName_,"genjet_axis1"  ,0);
      igenjetaxis2_= data.addMulti<float>(branchName_,"genjet_axis2"  ,0);
      igenjetMult_ = data.addMulti<size16>(branchName_,"genjet_jetMult",0);
      igenjetcharge_  =data.addMulti<float>(branchName_,"genjet_charge"    ,0);
      igenjetpullrap_ =data.addMulti<float>(branchName_,"genjet_pullrap"    ,0);
      igenjetpullphi_ =data.addMulti<float>(branchName_,"genjet_pullphi"    ,0);
    }
  }

  if(options_ & SAVEQGL) {
    ijetqgl_     =data.addMulti<float>(branchName_,"jet_qgl"    ,0);
  }

  if(options_ & SAVETOPASSOC) {
    iGenAssocPrtIndex_ = data.addMulti<size16>(branchName_,"prtassoc_partonIndex",0);
    iGenAssocJetIndex_ = data.addMulti<size16>(branchName_,"prtassoc_jetIndex",0);
    iGenAssocCont_     = data.addMulti<PartonMatching::conType>(branchName_,"prtassoc_jetCont",0);
  }

}
//--------------------------------------------------------------------------------------------------
template<typename Jet>
void JetFiller<Jet>::load(const edm::Event& iEvent, const edm::EventSetup &iSetup)
{
  reset();
  iEvent.getByToken(jetToken_,jets_);
  iEvent.getByToken(pfCandToken_, pfcands_);

  if(options_ & LOADGEN) {
    if(fillReGenJets_) iEvent.getByToken(reGenJetToken_,reGenJets_);
    else               iEvent.getByToken(reGenJetToken_,reGenJets_);
    iEvent.getByToken(flvAssocToken_,flvAssoc_);

    //clear caches
    reGenRecoRef_.clear();
    stdGenRecoRef_.clear();
  }
  if(options_ & LOADSUPER) {
    iEvent.getByToken(superJetToken_,superJets_);
    iEvent.getByToken(superJetAssocToken_,superJetAssoc_);
    iEvent.getByToken(superJetNsubToken_,superJetNsub_);
  }
  if(options_ & LOADJETSHAPE) {
    iEvent.getByToken(qglToken_,qgHandleQGL_);
  }
  // Fill JEC uncertainty variables
  if(!(options_ & LOADUNCFROMFILE)) {
    edm::ESHandle<JetCorrectorParametersCollection> JetCorParColl;
    iSetup.get<JetCorrectionsRecord>().get(jecLabel_, JetCorParColl);
    const JetCorrectorParameters& jetCorrParameters = (*JetCorParColl)["Uncertainty"];
    jecUnc_ = new JetCorrectionUncertainty(jetCorrParameters);

  }

  isLoaded_ = true;

}

//--------------------------------------------------------------------------------------------------
template<typename Jet>
void JetFiller<Jet>::fill()
{
  vector<int> genJetIndicies;
  int curIndex = -1;
  if(options_ & LOADGEN){
    const reco::GenJetCollection& genJets = fillReGenJets_ ? (*reGenJets_.product()) : (*stdGenJets_.product());
    genJetIndicies.reserve(genJets.size());
    for(unsigned int iJ = 0; iJ < genJets.size(); ++iJ){
      const auto& j = genJets[iJ];
      auto rJ = getRecoJet(iJ, fillReGenJets_);
      if(j.pt() < jptMin_
          && (rJ.isNull() ? 0 : rJ->pt()) < jptMin_ ){
        genJetIndicies.push_back(-1);
        continue;
      }
      genJetIndicies.push_back(++curIndex);

      //Basic information saved for all jets
      data.fillMulti<float>(igenjetpt_    ,j.pt());
      data.fillMulti<float>(igenjeteta_   ,j.eta());
      data.fillMulti<float>(igenjetphi_   ,j.phi());
      data.fillMulti<float>(igenjetmass_  ,j.mass());
      data.fillMulti<size8>(igenjetflavor_,fillReGenJets_ ? flvAssoc_->at(iJ) : 0);

      //Zero out complete information for low pT jets
      if(j.pt() < jptCompleteMin_){
        if(options_ & LOADJETSHAPE){
          assert(evtInfofiller_->isLoaded());
          qgTaggingVar_->compute(&j,false);
          data.fillMulti<float>(igenjetptD_     ,0);
          data.fillMulti<float>(igenjetaxis1_   ,0);
          data.fillMulti<float>(igenjetaxis2_   ,0);
          data.fillMulti<size16>(igenjetMult_   ,0);
          data.fillMulti<float>(igenjetcharge_  ,0);
          data.fillMulti<float>(igenjetpullrap_ ,0);
          data.fillMulti<float>(igenjetpullphi_ ,0);
        }
        continue;
      }

      //Fill it in for higher pt jets
      if(options_ & LOADJETSHAPE){
        assert(evtInfofiller_->isLoaded());
        qgTaggingVar_->compute(&j,false);
        data.fillMulti<float>(igenjetptD_     ,qgTaggingVar_->getPtD());
        data.fillMulti<float>(igenjetaxis1_   ,qgTaggingVar_->getAxis1());
        data.fillMulti<float>(igenjetaxis2_   ,qgTaggingVar_->getAxis2());
        data.fillMulti<size16>(igenjetMult_   ,convertTo<size16>(qgTaggingVar_->getTotalMult(),"JetFiller::genJetMult"));
        data.fillMulti<float>(igenjetcharge_   ,float(qgTaggingVar_->getJetCharge(&j)));
        double jetPullRap = 0;
        double jetPullPhi = 0;
        qgTaggingVar_->getPull(&j,jetPullRap,jetPullPhi);
        data.fillMulti<float>(igenjetpullrap_   ,float(jetPullRap));
        data.fillMulti<float>(igenjetpullphi_   ,float(jetPullPhi));
      }
    }

    if(options_ & SAVETOPASSOC) {
      const TopDecayMatching::Partons& partons = genParticleFiller_->getPartons(genJets);
      for(const auto p : partons){
        bool firstJet = true;
        for(const auto& ja : p.jetAssoc){
          //check to see if in the stored jet collection
          if(genJetIndicies[ja.first] < 0) continue;
          //make sure that it is above our min pT threshold
          if(genJets[ja.first].pt() < jptCompleteMin_) continue;

          PartonMatching::conType con = PartonMatching::toContainmentType(ja.second.energy()/p.sumFinal.energy());
          //if the containment is less than 1% leave it off the list
          if(con == 0) continue;
          if(firstJet){
            //if the first jet of the parton tag it by making th containment negative
            con *= -1;
            //add the parton index
            data.fillMulti<size16>(iGenAssocPrtIndex_,convertTo<size16>(p.storedIndex,"JetFiller::prtassoc_partonIndex"));
            firstJet = false;
          }
          data.fillMulti<size16>(iGenAssocJetIndex_,convertTo<size16>(ja.first,"JetFiller::prtassoc_jetIndex"));
          data.fillMulti<PartonMatching::conType>(iGenAssocCont_,con);
        }
      }
    }
  }

  vector<int> filledSJIndex;
  int curSJIndex = -1;
  if(options_ & LOADSUPER){
    filledSJIndex.reserve(superJets_->size());
    for(unsigned int iJ = 0; iJ < superJets_->size(); ++iJ){
      const auto& j = superJets_->at(iJ);
      if(j.pt() < jptCompleteMin_){ filledSJIndex.push_back(-1); continue;}
      filledSJIndex.push_back(++curSJIndex);
      data.fillMulti<float>(isuperjetpt_    ,j.pt());
      data.fillMulti<float>(isuperjeteta_   ,j.eta());
      data.fillMulti<float>(isuperjetphi_   ,j.phi());
      data.fillMulti<float>(isuperjetmass_  ,j.mass());
      data.fillMulti<size16>(isuperjetnsubjets_, convertTo<size16>(superJetNsub_->at(iJ),"JetFiller::superJetNsubjets"));
    }
  }


  for(unsigned int iJ = 0; iJ < jets_->size(); ++iJ){
    const Jet& j = jets_->at(iJ);
    if(j.pt() < jptMin_) continue;

    //Basic information saved for all jets
    data.fillMulti<float>(ijetpt_   ,j.pt());
    data.fillMulti<float>(ijeteta_  ,j.eta());
    data.fillMulti<float>(ijetphi_  ,j.phi());
    data.fillMulti<float>(ijetmass_ ,j.mass());

    if(options_ & LOADGEN) {
      const reco::GenJetRef gJ = fillReGenJets_ ? getReGenJet(j,iJ) : getStdGenJet(j);
      if(gJ.isNonnull()) {
        data.fillMulti<int16>(ijetgenindex_,convertTo<int16>(genJetIndicies[gJ.key()],"JetFiller::genJetIndex"));
      } else {
        data.fillMulti<int16>(ijetgenindex_   );
      }
    }

    /* Fill RecoJet JEC Uncertainties */
    jecUnc_->setJetEta(j.eta());
    jecUnc_->setJetPt(j.pt());
    data.fillMulti<float>(ijetuncertainty_, jecUnc_->getUncertainty(true));

    //Zero out complete information for low pT jets
    if(j.pt() < jptCompleteMin_){
      data.fillMulti<float>(ijetptraw_   ,0);
      data.fillMulti<float>(ijetpuId_    ,0);
      data.fillMulti<float>(ijetcsv_     ,0);
      data.fillMulti<float>(ijetcvsl_    ,0);	
      data.fillMulti<float>(ijetcvsb_    ,0);		
      data.fillMulti<bool> (ijetlooseId_ ,false);
      data.fillMulti<bool> (ijettightId_ ,false);
      if(options_ & FILLJETCHHADN){
        data.fillMulti<int> (ijetchHadN2_       ,0);
        data.fillMulti<int> (ijetchHadN4_       ,0);
        data.fillMulti<int> (ijetchHadN6_       ,0);
      }
      if(options_ & FILLJETEXTRA) {
        data.fillMulti<float> (ijetchHadEnFrac_   ,0);
        data.fillMulti<float> (ijetchEmEnFrac_    ,0);
        data.fillMulti<float> (ijetmuEnFrac_      ,0);
        data.fillMulti<float> (ijetelEnFrac_      ,0);
        data.fillMulti<float> (ijetneuHadEnFrac_  ,0);
        data.fillMulti<float> (ijetneuEmEnFrac_   ,0);
        data.fillMulti<float> (ijetphoEnFrac_     ,0);
        data.fillMulti<int>   (ijetchMult_        ,0);
        data.fillMulti<int>   (ijetneuMult_       ,0);
        data.fillMulti<int>   (ijetchHadMult_     ,0);
        data.fillMulti<int>   (ijetelMult_        ,0);
        data.fillMulti<int>   (ijetmuMult_        ,0);
        data.fillMulti<int>   (ijetneuHadMult_    ,0);
        data.fillMulti<int>   (ijetphoMult_       ,0);
      }
      if(options_ & LOADSUPER) {
        data.fillMulti<int16>(ijetsuperindex_,-1);
      }
      if(options_ & LOADJETSHAPE){
        data.fillMulti<float>(ijetarea_  ,0);
        data.fillMulti<float>(ijetbetaStar_,0);
        data.fillMulti<float>(ijetptD_     ,0);
        data.fillMulti<float>(ijetaxis1_   ,0);
        data.fillMulti<float>(ijetaxis2_   ,0);
        data.fillMulti<size16>(ijetMult_   ,0);
        data.fillMulti<float>(ijetcharge_  ,0);
        data.fillMulti<float>(ijetpullrap_ ,0);
        data.fillMulti<float>(ijetpullphi_ ,0);
      } // LOADJETSHAPE
      if(options_ & SAVEQGL) {
        data.fillMulti<float>(ijetqgl_   ,0);
      } // SAVEQGL
      continue;
    }

    //Fill it in for higher pt jets
    data.fillMulti<float>(ijetptraw_,getJecUncorrection(j));
    data.fillMulti<float>(ijetpuId_ ,getPUJetId(j));
    data.fillMulti<float>(ijetcsv_  ,getbDisc(j));
    data.fillMulti<float>(ijetcvsl_ ,getcvslDisc(j));	
    data.fillMulti<float>(ijetcvsb_ ,getcvsbDisc(j));		
    data.fillMulti<bool> (ijetlooseId_ ,JetFunctions::passLooseJetId(j));
    data.fillMulti<bool> (ijettightId_ ,JetFunctions::passTightJetId(j));

    if(options_ & FILLJETCHHADN) {
      assert(pfCandidateFiller_->isLoaded());
      int jetchHadN2_=0, jetchHadN4_=0, jetchHadN6_=0;
      for(unsigned int iPF = 0; iPF < pfcands_->size(); ++iPF){
        const auto* p = &pfcands_->at(iPF);
        if(abs(p->pdgId()) != 211) continue;
        int ipfjet = pfCandidateFiller_->getContainingJetIndex(p);
        if(ipfjet<0) continue;
        const pat::Jet &pfjet = (*jets_)[ipfjet];
        if(pfjet.pt() != j.pt()) continue;
        if(p->pt() > 2.) jetchHadN2_++;        
        if(p->pt() > 4.) jetchHadN4_++;
        if(p->pt() > 6.) jetchHadN6_++;
      }
      data.fillMulti<int>   (ijetchHadN2_       ,jetchHadN2_);
      data.fillMulti<int>   (ijetchHadN4_       ,jetchHadN4_);
      data.fillMulti<int>   (ijetchHadN6_       ,jetchHadN6_);
    }

    if(options_ & FILLJETEXTRA) {
      data.fillMulti<float> (ijetchHadEnFrac_   ,j.chargedHadronEnergyFraction());
      data.fillMulti<float> (ijetchEmEnFrac_    ,j.chargedEmEnergyFraction());
      data.fillMulti<float> (ijetmuEnFrac_      ,j.muonEnergyFraction());
      data.fillMulti<float> (ijetelEnFrac_      ,j.electronEnergyFraction());
      data.fillMulti<float> (ijetneuHadEnFrac_  ,j.neutralHadronEnergyFraction());
      data.fillMulti<float> (ijetneuEmEnFrac_   ,j.neutralEmEnergyFraction());
      data.fillMulti<float> (ijetphoEnFrac_     ,j.photonEnergyFraction());
      data.fillMulti<int>   (ijetchMult_        ,j.chargedMultiplicity());
      data.fillMulti<int>   (ijetneuMult_       ,j.neutralMultiplicity());
      data.fillMulti<int>   (ijetchHadMult_     ,j.chargedHadronMultiplicity());
      data.fillMulti<int>   (ijetelMult_        ,j.electronMultiplicity());
      data.fillMulti<int>   (ijetmuMult_        ,j.muonMultiplicity());
      data.fillMulti<int>   (ijetneuHadMult_    ,j.neutralHadronMultiplicity());
      data.fillMulti<int>   (ijetphoMult_       ,j.photonMultiplicity());
    }



    if(options_ & LOADSUPER) {
      const int sjAssoc = superJetAssoc_->at(iJ);
      data.fillMulti<int16>(ijetsuperindex_, sjAssoc > -1 ? convertTo<int16>(filledSJIndex[sjAssoc], "JetFiller::superJetIndex") : -1);
    }

    if(options_ & LOADJETSHAPE){
      assert(evtInfofiller_->isLoaded());
      // for official qgTagger
      qgTaggingVar_->compute(&j,true);
      data.fillMulti<float>(ijetarea_ ,j.jetArea());
      data.fillMulti<float>(ijetbetaStar_,getBetaStar(j));
      data.fillMulti<float>(ijetptD_     ,qgTaggingVar_->getPtD());
      data.fillMulti<float>(ijetaxis1_   ,qgTaggingVar_->getAxis1());
      data.fillMulti<float>(ijetaxis2_   ,qgTaggingVar_->getAxis2());
      data.fillMulti<size16>(ijetMult_   ,convertTo<size16>(qgTaggingVar_->getTotalMult(),"JetFiller::recoJetMult"));
      data.fillMulti<float>(ijetcharge_   ,float(qgTaggingVar_->getJetCharge(&j)));
      double jetPullRap = 0;
      double jetPullPhi = 0;
      qgTaggingVar_->getPull(&j,jetPullRap,jetPullPhi);
      data.fillMulti<float>(ijetpullrap_   ,float(jetPullRap));
      data.fillMulti<float>(ijetpullphi_   ,float(jetPullPhi));

    } // LOADJETSHAPE
    if(options_ & SAVEQGL) {
      float qgQGL = (*qgHandleQGL_ )[reco::CandidatePtr(jets_, iJ)];
      data.fillMulti<float>(ijetqgl_ , qgQGL );
    } // SAVEQGL

  }

  if(!(options_ & LOADUNCFROMFILE)) delete jecUnc_;
  isFilled_ = true;
}
}

#endif
